<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/src/Service/ItemsProvider.php">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/Service/ItemsProvider.php" />
              <option name="originalContent" value="&lt;?php&#10;&#10;namespace App\Service;&#10;&#10;use App\Entity\Items;&#10;use App\Repository\ItemsRepository;&#10;use Doctrine\ORM\EntityManagerInterface;&#10;use Symfony\Component\HttpFoundation\File\UploadedFile;&#10;&#10;class ItemsProvider&#10;{&#10;    /** @var Items[] */&#10;    private array $cache = [];&#10;&#10;    public function __construct(&#10;        private ItemsRepository $repository,&#10;        private EntityManagerInterface $em,&#10;        private WarframeApiClient $apiClient,&#10;    ) {}&#10;&#10;    public function getByName(string $name): ?Items&#10;    {&#10;        $searchName = $this-&gt;normalizeName($name);&#10;&#10;        // 1. Check dans l’array du service (cache de la requête)&#10;        if (isset($this-&gt;cache[$searchName])) {&#10;            return $this-&gt;cache[$searchName];&#10;        }&#10;&#10;        // 2. Check en BDD&#10;        $item = $this-&gt;repository-&gt;findOneBy(['searchName' =&gt; $searchName]);&#10;        if ($item) {&#10;            $this-&gt;cache[$searchName] = $item;&#10;            return $item;&#10;        }&#10;&#10;        // 3. Sinon, fetch via l’API (EN + FR)&#10;        $dataEn = $this-&gt;apiClient-&gt;searchItem($name, 'en');&#10;        $dataFr = $this-&gt;apiClient-&gt;searchItem($name, 'fr');&#10;&#10;        if (empty($dataEn)) {&#10;            // rien trouvé du tout → tu peux retourner null&#10;            // ou lever une exception selon ton choix&#10;            return null;&#10;        }&#10;&#10;        // on prend le premier résultat EN comme base&#10;        $en = $dataEn[0];&#10;        $fr = !empty($dataFr) ? $dataFr[0] : null;&#10;&#10;        $item = new Items();&#10;        $item-&gt;setSearchName($searchName);&#10;        $item-&gt;setUniqueName($en['uniqueName'] ?? null);&#10;        $item-&gt;setNameEn($en['name'] ?? null);&#10;        $item-&gt;setDescriptionEn($en['description'] ?? null);&#10;        $item-&gt;setNameFr($fr['name'] ?? null);&#10;        $item-&gt;setDescriptionFr($fr['description'] ?? null);&#10;&#10;        $imageName = $en['imageName'] ?? null;&#10;&#10;        if ($imageName) {&#10;            $imageUrl = 'https://cdn.warframestat.us/img/' . $imageName;&#10;            $item-&gt;setImageUrl($imageUrl);&#10;&#10;            try {&#10;                $contents = @file_get_contents($imageUrl);&#10;                if ($contents !== false) {&#10;                    $ext = pathinfo($imageName, PATHINFO_EXTENSION) ?: 'jpg';&#10;                    $tmpPath = sys_get_temp_dir() . '/' . uniqid('wf_', true) . '.' . $ext;&#10;                    file_put_contents($tmpPath, $contents);&#10;&#10;                    // Détecter le mime type si possible&#10;                    $mime = @mime_content_type($tmpPath) ?: null;&#10;&#10;                    // Création d'un UploadedFile en mode test pour contourner les vérifs PHP upload&#10;                    $uploaded = new UploadedFile(&#10;                        $tmpPath,&#10;                        basename($imageName),&#10;                        $mime,&#10;                        null,&#10;                        null,&#10;                        true&#10;                    );&#10;&#10;                    $item-&gt;setImageFile($uploaded);&#10;                }&#10;            } catch (\Throwable $e) {&#10;&#10;            }&#10;        }&#10;&#10;        $item-&gt;setCategory($en['category'] ?? null);&#10;        $item-&gt;setProductCategory($en['productCategory'] ?? null);&#10;&#10;        // 4. Sauvegarde en BDD&#10;        $this-&gt;em-&gt;persist($item);&#10;        $this-&gt;em-&gt;flush();&#10;&#10;        // 5. Ajout dans l’array cache&#10;        $this-&gt;cache[$searchName] = $item;&#10;&#10;        return $item;&#10;    }&#10;&#10;    private function normalizeName(string $name): string&#10;    {&#10;        return mb_strtolower(trim($name));&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="&lt;?php&#10;&#10;namespace App\Service;&#10;&#10;use App\Entity\Items;&#10;use App\Repository\ItemsRepository;&#10;use Doctrine\ORM\EntityManagerInterface;&#10;use Symfony\Component\HttpFoundation\File\UploadedFile;&#10;&#10;class ItemsProvider&#10;{&#10;    /** @var Items[] */&#10;    private array $cache = [];&#10;&#10;    public function __construct(&#10;        private ItemsRepository $repository,&#10;        private EntityManagerInterface $em,&#10;        private WarframeApiClient $apiClient,&#10;    ) {}&#10;&#10;    public function getByName(string $name): ?Items&#10;    {&#10;        $searchName = $this-&gt;normalizeName($name);&#10;&#10;        // 1. Check dans l’array du service (cache de la requête)&#10;        if (isset($this-&gt;cache[$searchName])) {&#10;            return $this-&gt;cache[$searchName];&#10;        }&#10;&#10;        // 2. Check en BDD&#10;        $item = $this-&gt;repository-&gt;findOneBy(['searchName' =&gt; $searchName]);&#10;        if ($item) {&#10;            $this-&gt;cache[$searchName] = $item;&#10;            return $item;&#10;        }&#10;&#10;        // 3. Sinon, fetch via l’API (EN + FR)&#10;        $dataEn = $this-&gt;apiClient-&gt;searchItem($name, 'en');&#10;        $dataFr = $this-&gt;apiClient-&gt;searchItem($name, 'fr');&#10;&#10;        if (empty($dataEn)) {&#10;            // rien trouvé du tout → tu peux retourner null&#10;            // ou lever une exception selon ton choix&#10;            return null;&#10;        }&#10;&#10;        // Sélection plus robuste : on essaie de trouver la meilleure correspondance&#10;        $en = null;&#10;        $fr = null;&#10;&#10;        $searchLower = mb_strtolower($searchName);&#10;&#10;        // 1) correspondance par uniqueName exacte&#10;        foreach ($dataEn as $candidate) {&#10;            if (isset($candidate['uniqueName']) &amp;&amp; mb_strtolower($candidate['uniqueName']) === $searchLower) {&#10;                $en = $candidate;&#10;                break;&#10;            }&#10;        }&#10;&#10;        // 2) sinon, privilégier les Warframes (si on cherche une warframe)&#10;        if ($en === null) {&#10;            foreach ($dataEn as $candidate) {&#10;                if (isset($candidate['category']) &amp;&amp; mb_strtolower($candidate['category']) === 'warframes') {&#10;                    $en = $candidate;&#10;                    break;&#10;                }&#10;            }&#10;        }&#10;&#10;        // 3) sinon, correspondance par nom exact (insensible à la casse)&#10;        if ($en === null) {&#10;            foreach ($dataEn as $candidate) {&#10;                if (isset($candidate['name']) &amp;&amp; mb_strtolower($candidate['name']) === $searchLower) {&#10;                    $en = $candidate;&#10;                    break;&#10;                }&#10;            }&#10;        }&#10;&#10;        // 4) fallback sur le premier élément&#10;        if ($en === null) {&#10;            $en = $dataEn[0];&#10;        }&#10;&#10;        // Extraire uniqueName pour une comparaison sûre&#10;        $enUnique = $en['uniqueName'] ?? null;&#10;&#10;        // Pour le FR : si possible on prend l'élément FR ayant le même uniqueName&#10;        if (!empty($dataFr)) {&#10;            foreach ($dataFr as $candidateFr) {&#10;                if ($enUnique !== null &amp;&amp; isset($candidateFr['uniqueName']) &amp;&amp; $candidateFr['uniqueName'] === $enUnique) {&#10;                    $fr = $candidateFr;&#10;                    break;&#10;                }&#10;            }&#10;            if ($fr === null) {&#10;                $fr = $dataFr[0];&#10;            }&#10;        }&#10;&#10;        $item = new Items();&#10;        $item-&gt;setSearchName($searchName);&#10;        $item-&gt;setUniqueName($en['uniqueName'] ?? null);&#10;        $item-&gt;setNameEn($en['name'] ?? null);&#10;        $item-&gt;setDescriptionEn($en['description'] ?? null);&#10;        $item-&gt;setNameFr($fr['name'] ?? null);&#10;        $item-&gt;setDescriptionFr($fr['description'] ?? null);&#10;&#10;        // Champs supplémentaires sûrs à mapper (existant dans l'entité)&#10;        $item-&gt;setType($en['type'] ?? null);&#10;        $item-&gt;setTradable($en['tradable'] ?? false);&#10;        $item-&gt;setCategory($en['category'] ?? null);&#10;        $item-&gt;setProductCategory($en['productCategory'] ?? null);&#10;&#10;        $imageName = $en['imageName'] ?? null;&#10;&#10;        if ($imageName) {&#10;            $imageUrl = 'https://cdn.warframestat.us/img/' . $imageName;&#10;            $item-&gt;setImageUrl($imageUrl);&#10;&#10;            try {&#10;                $contents = @file_get_contents($imageUrl);&#10;                if ($contents !== false) {&#10;                    $ext = pathinfo($imageName, PATHINFO_EXTENSION) ?: 'jpg';&#10;                    $tmpPath = sys_get_temp_dir() . '/' . uniqid('wf_', true) . '.' . $ext;&#10;                    file_put_contents($tmpPath, $contents);&#10;&#10;                    // Détecter le mime type si possible&#10;                    $mime = null;&#10;                    if (function_exists('mime_content_type')) {&#10;                        $mime = @mime_content_type($tmpPath) ?: null;&#10;                    }&#10;&#10;                    // Création d'un UploadedFile en mode test pour contourner les vérifs PHP upload&#10;                    $uploaded = new UploadedFile(&#10;                        $tmpPath,&#10;                        basename($imageName),&#10;                        $mime,&#10;                        null,&#10;                        null,&#10;                        true&#10;                    );&#10;&#10;                    $item-&gt;setImageFile($uploaded);&#10;                }&#10;            } catch (\Throwable $e) {&#10;                // ne pas bloquer si le téléchargement échoue&#10;            }&#10;        }&#10;&#10;        // 4. Sauvegarde en BDD&#10;        $this-&gt;em-&gt;persist($item);&#10;        $this-&gt;em-&gt;flush();&#10;&#10;        // 5. Ajout dans l’array cache&#10;        $this-&gt;cache[$searchName] = $item;&#10;&#10;        return $item;&#10;    }&#10;&#10;    private function normalizeName(string $name): string&#10;    {&#10;        return mb_strtolower(trim($name));&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>