<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/src/Service/WarframeApiCache.php">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/Service/WarframeApiCache.php" />
              <option name="originalContent" value="&lt;?php&#10;&#10;namespace App\Service;&#10;&#10;use Psr\Log\LoggerInterface;&#10;use Symfony\Contracts\Cache\CacheInterface;&#10;use Symfony\Contracts\Cache\ItemInterface;&#10;&#10;class WarframeApiCache&#10;{&#10;    public function __construct(&#10;        private WarframeApiClient $client,&#10;        private CacheInterface $cache,&#10;        private LoggerInterface $logger&#10;    ) {}&#10;&#10;    /**&#10;     * Récupère les résultats depuis le cache ou appelle l'API si absent.&#10;     * @param string $name&#10;     * @param string $language&#10;     * @param int $ttl en secondes&#10;     * @return array&#10;     */&#10;    public function searchItem(string $name, string $language = 'en', int $ttl = 300): array&#10;    {&#10;        $cacheKey = 'wf_search_' . md5($name . '|' . $language);&#10;&#10;        try {&#10;            return $this-&gt;cache-&gt;get($cacheKey, function (ItemInterface $item) use ($ttl, $name, $language) {&#10;                $item-&gt;expiresAfter(max(0, $ttl));&#10;&#10;                try {&#10;                    return $this-&gt;client-&gt;searchItem($name, $language);&#10;                } catch (\Throwable $e) {&#10;                    // En cas d'erreur dans l'appel API, on renvoie un tableau vide pour ne pas planter le cache&#10;                    return [];&#10;                }&#10;            });&#10;        } catch (\Throwable $e) {&#10;            $this-&gt;logger-&gt;error('WarframeApiCache get error', ['name' =&gt; $name, 'language' =&gt; $language, 'exception' =&gt; $e-&gt;getMessage()]);&#10;            return [];&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Tente de récupérer la valeur en cache sans appeler l'API.&#10;     * Retourne null si absent ou si l'adaptateur ne supporte pas l'accès direct.&#10;     * @param string $name&#10;     * @param string $language&#10;     * @return array|null&#10;     */&#10;    public function getFromCache(string $name, string $language = 'en'): ?array&#10;    {&#10;        $cacheKey = 'wf_search_' . md5($name . '|' . $language);&#10;&#10;        try {&#10;            // Si l'adaptateur expose getItem (PSR-6 AdapterInterface), utilisons-le pour vérifier sans exécuter la closure&#10;            if (method_exists($this-&gt;cache, 'getItem')) {&#10;                $item = $this-&gt;cache-&gt;getItem($cacheKey);&#10;                if ($item-&gt;isHit()) {&#10;                    return $item-&gt;get();&#10;                }&#10;                return null;&#10;            }&#10;&#10;            // Sinon, essayer une lecture sécurisée via get mais en forçant une closure qui ne contacte pas l'API&#10;            // ATTENTION: certains adaptateurs exécuteront la closure et la stockeront — évitons de faire cela.&#10;            return null;&#10;        } catch (\Throwable $e) {&#10;            $this-&gt;logger-&gt;warning('WarframeApiCache getFromCache error', ['name' =&gt; $name, 'language' =&gt; $language, 'exception' =&gt; $e-&gt;getMessage()]);&#10;            return null;&#10;        }&#10;    }&#10;}" />
              <option name="updatedContent" value="&lt;?php&#13;&#10;&#13;&#10;namespace App\Service;&#13;&#10;&#13;&#10;use Psr\Log\LoggerInterface;&#13;&#10;use Symfony\Contracts\Cache\CacheInterface;&#13;&#10;use Symfony\Contracts\Cache\ItemInterface;&#13;&#10;&#13;&#10;class WarframeApiCache&#13;&#10;{&#13;&#10;    public function __construct(&#13;&#10;        private WarframeApiClient $client,&#13;&#10;        private CacheInterface $cache,&#13;&#10;        private LoggerInterface $logger&#13;&#10;    ) {}&#13;&#10;&#13;&#10;    /**&#13;&#10;     * Récupère les résultats depuis le cache ou appelle l'API si absent.&#13;&#10;     * @param string $name&#13;&#10;     * @param string $language&#13;&#10;     * @param int $ttl en secondes&#13;&#10;     * @return array&#13;&#10;     */&#13;&#10;    public function searchItem(string $name, string $language = 'en', int $ttl = 300): array&#13;&#10;    {&#13;&#10;        $cacheKey = 'wf_search_' . md5($name . '|' . $language);&#13;&#10;&#13;&#10;        try {&#13;&#10;            return $this-&gt;cache-&gt;get($cacheKey, function (ItemInterface $item) use ($ttl, $name, $language) {&#13;&#10;                $item-&gt;expiresAfter(max(0, $ttl));&#13;&#10;&#13;&#10;                try {&#13;&#10;                    return $this-&gt;client-&gt;searchItem($name, $language);&#13;&#10;                } catch (\Throwable $e) {&#13;&#10;                    // En cas d'erreur dans l'appel API, on renvoie un tableau vide pour ne pas planter le cache&#13;&#10;                    return [];&#13;&#10;                }&#13;&#10;            });&#13;&#10;        } catch (\Throwable $e) {&#13;&#10;            $this-&gt;logger-&gt;error('WarframeApiCache get error', ['name' =&gt; $name, 'language' =&gt; $language, 'exception' =&gt; $e-&gt;getMessage()]);&#13;&#10;            return [];&#13;&#10;        }&#13;&#10;    }&#13;&#10;&#13;&#10;    /**&#13;&#10;     * Tente de récupérer la valeur en cache sans appeler l'API.&#13;&#10;     * Retourne null si absent ou si l'adaptateur ne supporte pas l'accès direct.&#13;&#10;     * @param string $name&#13;&#10;     * @param string $language&#13;&#10;     * @return array|null&#13;&#10;     */&#13;&#10;    public function getFromCache(string $name, string $language = 'en'): ?array&#13;&#10;    {&#13;&#10;        $cacheKey = 'wf_search_' . md5($name . '|' . $language);&#13;&#10;&#13;&#10;        try {&#13;&#10;            // Si l'adaptateur expose getItem (PSR-6 AdapterInterface), utilisons-le pour vérifier sans exécuter la closure&#13;&#10;            if (method_exists($this-&gt;cache, 'getItem')) {&#13;&#10;                $item = $this-&gt;cache-&gt;getItem($cacheKey);&#13;&#10;                if ($item-&gt;isHit()) {&#13;&#10;                    return $item-&gt;get();&#13;&#10;                }&#13;&#10;                return null;&#13;&#10;            }&#13;&#10;&#13;&#10;            // Sinon, essayer une lecture sécurisée via get mais en forçant une closure qui ne contacte pas l'API&#13;&#10;            // ATTENTION: certains adaptateurs exécuteront la closure et la stockeront — évitons de faire cela.&#13;&#10;            return null;&#13;&#10;        } catch (\Throwable $e) {&#13;&#10;            $this-&gt;logger-&gt;warning('WarframeApiCache getFromCache error', ['name' =&gt; $name, 'language' =&gt; $language, 'exception' =&gt; $e-&gt;getMessage()]);&#13;&#10;            return null;&#13;&#10;        }&#13;&#10;    }&#13;&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>