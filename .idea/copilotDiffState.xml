<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/src/Repository/ItemsRepository.php">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/Repository/ItemsRepository.php" />
              <option name="originalContent" value="&lt;?php&#10;&#10;namespace App\Repository;&#10;&#10;use App\Entity\Items;&#10;use Doctrine\Bundle\DoctrineBundle\Repository\ServiceEntityRepository;&#10;use Doctrine\Persistence\ManagerRegistry;&#10;&#10;/**&#10; * @extends ServiceEntityRepository&lt;Items&gt;&#10; */&#10;class ItemsRepository extends ServiceEntityRepository&#10;{&#10;    public function __construct(ManagerRegistry $registry)&#10;    {&#10;        parent::__construct($registry, Items::class);&#10;    }&#10;&#10;    /**&#10;     * Recherche simple par terme sur les champs name, uniqueName et searchNames (JSON).&#10;     * Retourne un tableau d'entités Items.&#10;     * @param string $term&#10;     * @param int|null $limit&#10;     * @return Items[]&#10;     */&#10;    public function findBySearchTerm(string $term, ?int $limit = 20): array&#10;    {&#10;        $qb = $this-&gt;createQueryBuilder('i');&#10;&#10;        // Recherche case-insensitive sur name et uniqueName&#10;        $qb-&gt;andWhere($qb-&gt;expr()-&gt;orX(&#10;            $qb-&gt;expr()-&gt;like('LOWER(i.name)', ':term'),&#10;            $qb-&gt;expr()-&gt;like('LOWER(i.uniqueName)', ':term')&#10;        ));&#10;&#10;        $qb-&gt;setParameter('term', '%' . mb_strtolower($term) . '%');&#10;&#10;        // Pour searchNames (json array), on effectue une comparaison textuelle sur le champ JSON&#10;        // en transformant en chaîne si le SGBD le supporte; sinon cette condition peut être ignorée.&#10;        // Ici on ajoute une condition LIKE sur le champ JSON -&gt; cela fonctionnera sur MySQL/Postgres&#10;        $qb-&gt;orWhere($qb-&gt;expr()-&gt;like('LOWER(CAST(i.searchNames AS string))', ':term'));&#10;&#10;        if ($limit !== null) {&#10;            $qb-&gt;setMaxResults($limit);&#10;        }&#10;&#10;        return $qb-&gt;getQuery()-&gt;getResult();&#10;    }&#10;}" />
              <option name="updatedContent" value="&lt;?php&#10;&#10;namespace App\Repository;&#10;&#10;use App\Entity\Items;&#10;use Doctrine\Bundle\DoctrineBundle\Repository\ServiceEntityRepository;&#10;use Doctrine\Persistence\ManagerRegistry;&#10;&#10;/**&#10; * @extends ServiceEntityRepository&lt;Items&gt;&#10; */&#10;class ItemsRepository extends ServiceEntityRepository&#10;{&#10;    public function __construct(ManagerRegistry $registry)&#10;    {&#10;        parent::__construct($registry, Items::class);&#10;    }&#10;&#10;    /**&#10;     * Recherche simple par terme sur les champs name, uniqueName et searchNames (JSON).&#10;     * Retourne un tableau d'entités Items.&#10;     * @param string $term&#10;     * @param int|null $limit&#10;     * @return Items[]&#10;     */&#10;    public function findBySearchTerm(string $term, ?int $limit = 20): array&#10;    {&#10;        $qb = $this-&gt;createQueryBuilder('i');&#10;&#10;        // Recherche case-insensitive sur name et uniqueName&#10;        $qb-&gt;andWhere($qb-&gt;expr()-&gt;orX(&#10;            $qb-&gt;expr()-&gt;like('LOWER(i.name)', ':term'),&#10;            $qb-&gt;expr()-&gt;like('LOWER(i.uniqueName)', ':term')&#10;        ));&#10;&#10;        $qb-&gt;setParameter('term', '%' . mb_strtolower($term) . '%');&#10;&#10;        // Pour searchNames (json array), on effectue une comparaison textuelle sur le champ JSON&#10;        // en transformant en chaîne si le SGBD le supporte; sinon cette condition peut être ignorée.&#10;        // Ici on ajoute une condition LIKE sur le champ JSON -&gt; cela fonctionnera sur MySQL/Postgres&#10;        $qb-&gt;orWhere($qb-&gt;expr()-&gt;like('LOWER(CAST(i.searchNames AS string))', ':term'));&#10;&#10;        if ($limit !== null) {&#10;            $qb-&gt;setMaxResults($limit);&#10;        }&#10;&#10;        return $qb-&gt;getQuery()-&gt;getResult();&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/Service/CategoryFilter.php">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/Service/CategoryFilter.php" />
              <option name="originalContent" value="&lt;?php&#10;&#10;namespace App\Service;&#10;&#10;use Symfony\Component\HttpFoundation\Request;&#10;&#10;class CategoryFilter&#10;{&#10;    /**&#10;     * Extrait et normalise la liste des catégories à exclure depuis la requête HTTP.&#10;     * @param Request $request&#10;     * @param string $paramName&#10;     * @param string $default&#10;     * @return string[]&#10;     */&#10;    public function getExcludedCategoriesFromRequest(Request $request, string $paramName = 'exclude', string $default = 'Skins,Glyphs,Resources,Misc'): array&#10;    {&#10;        $excludeParam = (string) $request-&gt;query-&gt;get($paramName, $default);&#10;        $excludedCategories = array_filter(array_map(function ($c) {&#10;            return mb_strtolower(trim($c));&#10;        }, explode(',', $excludeParam)));&#10;&#10;        return array_values($excludedCategories);&#10;    }&#10;&#10;    /**&#10;     * Vérifie si un item appartient à une des catégories à exclure.&#10;     * @param array $item&#10;     * @param string[] $excludedCategories (en minuscules)&#10;     * @return bool&#10;     */&#10;    public function isExcluded(array $item, array $excludedCategories): bool&#10;    {&#10;        $categoryField = $item['category'] ?? null;&#10;&#10;        if ($categoryField === null) {&#10;            return false;&#10;        }&#10;&#10;        $categories = [];&#10;        if (is_array($categoryField)) {&#10;            foreach ($categoryField as $c) {&#10;                if (is_string($c)) {&#10;                    $categories[] = mb_strtolower(trim($c));&#10;                }&#10;            }&#10;        } elseif (is_string($categoryField)) {&#10;            $categories[] = mb_strtolower(trim($categoryField));&#10;        }&#10;&#10;        if (empty($categories)) {&#10;            return false;&#10;        }&#10;&#10;        // Règles spécifiques : pour certaines catégories (Warframes, Primary, Secondary, Melee),&#10;        // ne garder que les items qui sont des primes (isPrime true). Les autres sont exclus.&#10;        $primeRequiredCategories = ['warframes', 'primary', 'secondary', 'melee'];&#10;        foreach ($primeRequiredCategories as $primeCat) {&#10;            if (in_array($primeCat, $categories, true)) {&#10;                // Interpréter proprement la valeur isPrime (peut être bool, int, string)&#10;                $isPrime = false;&#10;                if (array_key_exists('isPrime', $item)) {&#10;                    // filter_var gère &quot;true&quot;/&quot;false&quot;/&quot;1&quot;/&quot;0&quot; etc.&#10;                    $isPrime = (bool) filter_var($item['isPrime'], FILTER_VALIDATE_BOOLEAN, FILTER_NULL_ON_FAILURE);&#10;                }&#10;&#10;                // Si ce n'est pas une prime, on l'exclut (on garde uniquement les isPrime true)&#10;                if (!$isPrime) {&#10;                    return true;&#10;                }&#10;&#10;                // Si c'est une prime, on ne l'exclut pas pour cette règle — on continue les autres vérifications&#10;                break;&#10;            }&#10;        }&#10;&#10;        foreach ($categories as $cat) {&#10;            if (in_array($cat, $excludedCategories, true)) {&#10;                return true;&#10;            }&#10;        }&#10;&#10;        return false;&#10;    }&#10;&#10;    /**&#10;     * Filtre un tableau d'items pour exclure ceux dont la catégorie est dans la liste.&#10;     * @param array $items&#10;     * @param string[] $excludedCategories&#10;     * @return array&#10;     */&#10;    public function filter(array $items, array $excludedCategories): array&#10;    {&#10;        return array_values(array_filter($items, function ($item) use ($excludedCategories) {&#10;            if (!is_array($item)) {&#10;                return false;&#10;            }&#10;&#10;            return !$this-&gt;isExcluded($item, $excludedCategories);&#10;        }));&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="&lt;?php&#10;&#10;namespace App\Service;&#10;&#10;use Symfony\Component\HttpFoundation\Request;&#10;&#10;class CategoryFilter&#10;{&#10;    /**&#10;     * Extrait et normalise la liste des catégories à exclure depuis la requête HTTP.&#10;     * @param Request $request&#10;     * @param string $paramName&#10;     * @param string $default&#10;     * @return string[]&#10;     */&#10;    public function getExcludedCategoriesFromRequest(Request $request, string $paramName = 'exclude', string $default = 'Skins,Glyphs,Resources,Misc'): array&#10;    {&#10;        $excludeParam = (string) $request-&gt;query-&gt;get($paramName, $default);&#10;        $excludedCategories = array_filter(array_map(function ($c) {&#10;            return mb_strtolower(trim($c));&#10;        }, explode(',', $excludeParam)));&#10;&#10;        return array_values($excludedCategories);&#10;    }&#10;&#10;    /**&#10;     * Vérifie si un item appartient à une des catégories à exclure.&#10;     * @param array $item&#10;     * @param string[] $excludedCategories (en minuscules)&#10;     * @return bool&#10;     */&#10;    public function isExcluded(array $item, array $excludedCategories): bool&#10;    {&#10;        $categoryField = $item['category'] ?? null;&#10;&#10;        if ($categoryField === null) {&#10;            return false;&#10;        }&#10;&#10;        $categories = [];&#10;        if (is_array($categoryField)) {&#10;            foreach ($categoryField as $c) {&#10;                if (is_string($c)) {&#10;                    $categories[] = mb_strtolower(trim($c));&#10;                }&#10;            }&#10;        } elseif (is_string($categoryField)) {&#10;            $categories[] = mb_strtolower(trim($categoryField));&#10;        }&#10;&#10;        if (empty($categories)) {&#10;            return false;&#10;        }&#10;&#10;        // Règles spécifiques : pour certaines catégories (Warframes, Primary, Secondary, Melee),&#10;        // ne garder que les items qui sont des primes (isPrime true). Les autres sont exclus.&#10;        $primeRequiredCategories = ['warframes', 'primary', 'secondary', 'melee'];&#10;        foreach ($primeRequiredCategories as $primeCat) {&#10;            if (in_array($primeCat, $categories, true)) {&#10;                // Interpréter proprement la valeur isPrime (peut être bool, int, string)&#10;                $isPrime = false;&#10;                if (array_key_exists('isPrime', $item)) {&#10;                    // filter_var gère &quot;true&quot;/&quot;false&quot;/&quot;1&quot;/&quot;0&quot; etc.&#10;                    $isPrime = (bool) filter_var($item['isPrime'], FILTER_VALIDATE_BOOLEAN, FILTER_NULL_ON_FAILURE);&#10;                }&#10;&#10;                // Si ce n'est pas une prime, on l'exclut (on garde uniquement les isPrime true)&#10;                if (!$isPrime) {&#10;                    return true;&#10;                }&#10;&#10;                // Si c'est une prime, on ne l'exclut pas pour cette règle — on continue les autres vérifications&#10;                break;&#10;            }&#10;        }&#10;&#10;        foreach ($categories as $cat) {&#10;            if (in_array($cat, $excludedCategories, true)) {&#10;                return true;&#10;            }&#10;        }&#10;&#10;        return false;&#10;    }&#10;&#10;    /**&#10;     * Filtre un tableau d'items pour exclure ceux dont la catégorie est dans la liste.&#10;     * @param array $items&#10;     * @param string[] $excludedCategories&#10;     * @return array&#10;     */&#10;    public function filter(array $items, array $excludedCategories): array&#10;    {&#10;        return array_values(array_filter($items, function ($item) use ($excludedCategories) {&#10;            if (!is_array($item)) {&#10;                return false;&#10;            }&#10;&#10;            return !$this-&gt;isExcluded($item, $excludedCategories);&#10;        }));&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/Service/WarframeApiCache.php">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/Service/WarframeApiCache.php" />
              <option name="originalContent" value="&lt;?php&#10;&#10;namespace App\Service;&#10;&#10;use Psr\Log\LoggerInterface;&#10;use Symfony\Contracts\Cache\CacheInterface;&#10;use Symfony\Contracts\Cache\ItemInterface;&#10;&#10;class WarframeApiCache&#10;{&#10;    public function __construct(&#10;        private WarframeApiClient $client,&#10;        private CacheInterface $cache,&#10;        private LoggerInterface $logger&#10;    ) {}&#10;&#10;    /**&#10;     * Récupère les résultats depuis le cache ou appelle l'API si absent.&#10;     * @param string $name&#10;     * @param string $language&#10;     * @param int $ttl en secondes&#10;     * @return array&#10;     */&#10;    public function searchItem(string $name, string $language = 'en', int $ttl = 300): array&#10;    {&#10;        $cacheKey = 'wf_search_' . md5($name . '|' . $language);&#10;&#10;        try {&#10;            return $this-&gt;cache-&gt;get($cacheKey, function (ItemInterface $item) use ($ttl, $name, $language) {&#10;                $item-&gt;expiresAfter(max(0, $ttl));&#10;&#10;                try {&#10;                    return $this-&gt;client-&gt;searchItem($name, $language);&#10;                } catch (\Throwable $e) {&#10;                    // En cas d'erreur dans l'appel API, on renvoie un tableau vide pour ne pas planter le cache&#10;                    return [];&#10;                }&#10;            });&#10;        } catch (\Throwable $e) {&#10;            $this-&gt;logger-&gt;error('WarframeApiCache get error', ['name' =&gt; $name, 'language' =&gt; $language, 'exception' =&gt; $e-&gt;getMessage()]);&#10;            return [];&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Tente de récupérer la valeur en cache sans appeler l'API.&#10;     * Retourne null si absent ou si l'adaptateur ne supporte pas l'accès direct.&#10;     * @param string $name&#10;     * @param string $language&#10;     * @return array|null&#10;     */&#10;    public function getFromCache(string $name, string $language = 'en'): ?array&#10;    {&#10;        $cacheKey = 'wf_search_' . md5($name . '|' . $language);&#10;&#10;        try {&#10;            // Si l'adaptateur expose getItem (PSR-6 AdapterInterface), utilisons-le pour vérifier sans exécuter la closure&#10;            if (method_exists($this-&gt;cache, 'getItem')) {&#10;                $item = $this-&gt;cache-&gt;getItem($cacheKey);&#10;                if ($item-&gt;isHit()) {&#10;                    return $item-&gt;get();&#10;                }&#10;                return null;&#10;            }&#10;&#10;            // Sinon, essayer une lecture sécurisée via get mais en forçant une closure qui ne contacte pas l'API&#10;            // ATTENTION: certains adaptateurs exécuteront la closure et la stockeront — évitons de faire cela.&#10;            return null;&#10;        } catch (\Throwable $e) {&#10;            $this-&gt;logger-&gt;warning('WarframeApiCache getFromCache error', ['name' =&gt; $name, 'language' =&gt; $language, 'exception' =&gt; $e-&gt;getMessage()]);&#10;            return null;&#10;        }&#10;    }&#10;}" />
              <option name="updatedContent" value="&lt;?php&#13;&#10;&#13;&#10;namespace App\Service;&#13;&#10;&#13;&#10;use Psr\Log\LoggerInterface;&#13;&#10;use Symfony\Contracts\Cache\CacheInterface;&#13;&#10;use Symfony\Contracts\Cache\ItemInterface;&#13;&#10;&#13;&#10;class WarframeApiCache&#13;&#10;{&#13;&#10;    public function __construct(&#13;&#10;        private WarframeApiClient $client,&#13;&#10;        private CacheInterface $cache,&#13;&#10;        private LoggerInterface $logger&#13;&#10;    ) {}&#13;&#10;&#13;&#10;    /**&#13;&#10;     * Récupère les résultats depuis le cache ou appelle l'API si absent.&#13;&#10;     * @param string $name&#13;&#10;     * @param string $language&#13;&#10;     * @param int $ttl en secondes&#13;&#10;     * @return array&#13;&#10;     */&#13;&#10;    public function searchItem(string $name, string $language = 'en', int $ttl = 300): array&#13;&#10;    {&#13;&#10;        $cacheKey = 'wf_search_' . md5($name . '|' . $language);&#13;&#10;&#13;&#10;        try {&#13;&#10;            return $this-&gt;cache-&gt;get($cacheKey, function (ItemInterface $item) use ($ttl, $name, $language) {&#13;&#10;                $item-&gt;expiresAfter(max(0, $ttl));&#13;&#10;&#13;&#10;                try {&#13;&#10;                    return $this-&gt;client-&gt;searchItem($name, $language);&#13;&#10;                } catch (\Throwable $e) {&#13;&#10;                    // En cas d'erreur dans l'appel API, on renvoie un tableau vide pour ne pas planter le cache&#13;&#10;                    return [];&#13;&#10;                }&#13;&#10;            });&#13;&#10;        } catch (\Throwable $e) {&#13;&#10;            $this-&gt;logger-&gt;error('WarframeApiCache get error', ['name' =&gt; $name, 'language' =&gt; $language, 'exception' =&gt; $e-&gt;getMessage()]);&#13;&#10;            return [];&#13;&#10;        }&#13;&#10;    }&#13;&#10;&#13;&#10;    /**&#13;&#10;     * Tente de récupérer la valeur en cache sans appeler l'API.&#13;&#10;     * Retourne null si absent ou si l'adaptateur ne supporte pas l'accès direct.&#13;&#10;     * @param string $name&#13;&#10;     * @param string $language&#13;&#10;     * @return array|null&#13;&#10;     */&#13;&#10;    public function getFromCache(string $name, string $language = 'en'): ?array&#13;&#10;    {&#13;&#10;        $cacheKey = 'wf_search_' . md5($name . '|' . $language);&#13;&#10;&#13;&#10;        try {&#13;&#10;            // Si l'adaptateur expose getItem (PSR-6 AdapterInterface), utilisons-le pour vérifier sans exécuter la closure&#13;&#10;            if (method_exists($this-&gt;cache, 'getItem')) {&#13;&#10;                $item = $this-&gt;cache-&gt;getItem($cacheKey);&#13;&#10;                if ($item-&gt;isHit()) {&#13;&#10;                    return $item-&gt;get();&#13;&#10;                }&#13;&#10;                return null;&#13;&#10;            }&#13;&#10;&#13;&#10;            // Sinon, essayer une lecture sécurisée via get mais en forçant une closure qui ne contacte pas l'API&#13;&#10;            // ATTENTION: certains adaptateurs exécuteront la closure et la stockeront — évitons de faire cela.&#13;&#10;            return null;&#13;&#10;        } catch (\Throwable $e) {&#13;&#10;            $this-&gt;logger-&gt;warning('WarframeApiCache getFromCache error', ['name' =&gt; $name, 'language' =&gt; $language, 'exception' =&gt; $e-&gt;getMessage()]);&#13;&#10;            return null;&#13;&#10;        }&#13;&#10;    }&#13;&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/templates/home/index.html.twig">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/templates/home/index.html.twig" />
              <option name="originalContent" value="{% extends 'base.html.twig' %}&#10;&#10;{% block title %}{{ 'home'|trans }}{% endblock %}&#10;&#10;{% block body %}&#10;    &lt;div id=&quot;home&quot; class=&quot;container&quot;&gt;&#10;        &lt;div class=&quot;home&quot;&gt;&#10;            &lt;div class=&quot;search-container&quot;&gt;&#10;                &lt;form id=&quot;search-form&quot;&#10;                      hx-get=&quot;{{ path('search') }}&quot;&#10;                      hx-target=&quot;#results&quot;&#10;                      hx-swap=&quot;innerHTML&quot;&#10;                      hx-trigger=&quot;submit&quot;&gt;&#10;                    &lt;input id=&quot;search-input&quot; name=&quot;q&quot; type=&quot;search&quot; placeholder=&quot;Recherche...&quot; autocomplete=&quot;off&quot;&#10;                           hx-trigger=&quot;keyup changed delay:300ms&quot;&#10;                           hx-get=&quot;{{ path('search') }}&quot;&#10;                           hx-target=&quot;#results&quot;&#10;                           hx-swap=&quot;innerHTML&quot; /&gt;&#10;                    &lt;button type=&quot;submit&quot;&gt;Rechercher&lt;/button&gt;&#10;                    &lt;span id=&quot;spinner&quot; style=&quot;display:none;&quot;&gt;Recherche...&lt;/span&gt;&#10;                &lt;/form&gt;&#10;&#10;                &lt;div id=&quot;results&quot; class=&quot;search-results-container&quot;&gt;&#10;                &lt;/div&gt;&#10;            &lt;/div&gt;&#10;        &lt;/div&gt;&#10;    &lt;/div&gt;&#10;{% endblock %}&#10;" />
              <option name="updatedContent" value="{% extends 'base.html.twig' %}&#10;&#10;{% block title %}{{ 'home'|trans }}{% endblock %}&#10;&#10;{% block body %}&#10;    &lt;div id=&quot;home&quot; class=&quot;container&quot;&gt;&#10;        &lt;div class=&quot;home&quot;&gt;&#10;            &lt;div class=&quot;search-container&quot;&gt;&#10;                &lt;form id=&quot;search-form&quot;&#10;                      hx-get=&quot;{{ path('search') }}&quot;&#10;                      hx-target=&quot;#results&quot;&#10;                      hx-swap=&quot;innerHTML&quot;&#10;                      hx-trigger=&quot;submit&quot;&gt;&#10;                    &lt;input id=&quot;search-input&quot; name=&quot;q&quot; type=&quot;search&quot; placeholder=&quot;Recherche...&quot; autocomplete=&quot;off&quot;&#10;                           hx-trigger=&quot;keyup changed delay:300ms&quot;&#10;                           hx-get=&quot;{{ path('search') }}&quot;&#10;                           hx-target=&quot;#results&quot;&#10;                           hx-swap=&quot;innerHTML&quot; /&gt;&#10;                    &lt;button type=&quot;submit&quot;&gt;Rechercher&lt;/button&gt;&#10;                    &lt;span id=&quot;spinner&quot; style=&quot;display:none;&quot;&gt;Recherche...&lt;/span&gt;&#10;                &lt;/form&gt;&#10;&#10;                &lt;div id=&quot;results&quot; class=&quot;search-results-container&quot;&gt;&#10;                &lt;/div&gt;&#10;            &lt;/div&gt;&#10;        &lt;/div&gt;&#10;    &lt;/div&gt;&#10;{% endblock %}" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>