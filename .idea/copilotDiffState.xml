<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/src/Service/ItemsProvider.php">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/Service/ItemsProvider.php" />
              <option name="originalContent" value="&lt;?php&#10;&#10;namespace App\Service;&#10;&#10;use App\Entity\Items;&#10;use App\Repository\ItemsRepository;&#10;use Doctrine\ORM\EntityManagerInterface;&#10;use Symfony\Component\HttpFoundation\File\UploadedFile;&#10;&#10;class ItemsProvider&#10;{&#10;    /** @var Items[] */&#10;    private array $cache = [];&#10;&#10;    public function __construct(&#10;        private ItemsRepository $repository,&#10;        private EntityManagerInterface $em,&#10;        private WarframeApiClient $apiClient,&#10;    ) {}&#10;&#10;    public function getByName(string $name): ?Items&#10;    {&#10;        $searchName = $this-&gt;normalizeName($name);&#10;&#10;        // 1. Check dans l’array du service (cache de la requête)&#10;        if (isset($this-&gt;cache[$searchName])) {&#10;            return $this-&gt;cache[$searchName];&#10;        }&#10;&#10;        // 2. Check en BDD en comparant nameEn/nameFr/uniqueName ou le JSON search_names&#10;        $item = $this-&gt;repository-&gt;findOneBySearchNameMatching($searchName);&#10;        if ($item) {&#10;            // si l'enregistrement existe mais ne contient pas le searchName dans le JSON, on l'ajoute&#10;            if (!in_array($searchName, $item-&gt;getSearchNames(), true)) {&#10;                $item-&gt;addSearchName($searchName);&#10;                $this-&gt;em-&gt;persist($item);&#10;                $this-&gt;em-&gt;flush();&#10;            }&#10;&#10;            $this-&gt;cache[$searchName] = $item;&#10;            return $item;&#10;        }&#10;&#10;        // 3. Sinon, fetch via l’API (EN + FR)&#10;        $dataEn = $this-&gt;apiClient-&gt;searchItem($name, 'en');&#10;        $dataFr = $this-&gt;apiClient-&gt;searchItem($name, 'fr');&#10;&#10;        if (empty($dataEn)) {&#10;            // rien trouvé du tout → tu peux retourner null&#10;            // ou lever une exception selon ton choix&#10;            return null;&#10;        }&#10;&#10;        // on prend le premier résultat EN comme base&#10;        $en = $dataEn[0];&#10;        $fr = !empty($dataFr) ? $dataFr[0] : null;&#10;&#10;        $item = new Items();&#10;        $item-&gt;setSearchName($searchName);&#10;        $item-&gt;setUniqueName($en['uniqueName'] ?? null);&#10;        $item-&gt;setNameEn($en['name'] ?? null);&#10;        $item-&gt;setDescriptionEn($en['description'] ?? null);&#10;        $item-&gt;setNameFr($fr['name'] ?? null);&#10;        $item-&gt;setDescriptionFr($fr['description'] ?? null);&#10;&#10;        $imageName = $en['imageName'] ?? null;&#10;&#10;        if ($imageName) {&#10;            $imageUrl = 'https://cdn.warframestat.us/img/' . $imageName;&#10;            $item-&gt;setImageUrl($imageUrl);&#10;&#10;            try {&#10;                $contents = @file_get_contents($imageUrl);&#10;                if ($contents !== false) {&#10;                    $ext = pathinfo($imageName, PATHINFO_EXTENSION) ?: 'jpg';&#10;                    $tmpPath = sys_get_temp_dir() . '/' . uniqid('wf_', true) . '.' . $ext;&#10;                    file_put_contents($tmpPath, $contents);&#10;&#10;                    // Déduire un mime simple depuis l'extension pour éviter l'appel à ext-fileinfo&#10;                    $extLower = strtolower($ext);&#10;                    $mime = match ($extLower) {&#10;                        'png' =&gt; 'image/png',&#10;                        'jpg', 'jpeg' =&gt; 'image/jpeg',&#10;                        'gif' =&gt; 'image/gif',&#10;                        'webp' =&gt; 'image/webp',&#10;                        default =&gt; null,&#10;                    };&#10;&#10;                    // Création d'un UploadedFile en mode test pour contourner les vérifs PHP upload&#10;                    $uploaded = new UploadedFile(&#10;                        $tmpPath,&#10;                        basename($imageName),&#10;                        $mime,&#10;                        null,&#10;                        true&#10;                    );&#10;&#10;                    $item-&gt;setImageFile($uploaded);&#10;                }&#10;            } catch (\Throwable $e) {&#10;&#10;            }&#10;        }&#10;&#10;        $item-&gt;setCategory($en['category'] ?? null);&#10;        $item-&gt;setProductCategory($en['productCategory'] ?? null);&#10;&#10;        // Si l'API renvoie des components, tenter de récupérer/créer chacun d'eux&#10;        if (!empty($en['components']) &amp;&amp; is_array($en['components'])) {&#10;            foreach ($en['components'] as $component) {&#10;                $compName = $component['name'] ?? ($component['uniqueName'] ?? null);&#10;                if (!$compName) {&#10;                    continue;&#10;                }&#10;&#10;                $compSearch = $this-&gt;normalizeName($compName);&#10;&#10;                // éviter les références circulaires vers soi-même&#10;                if ($compSearch === $searchName) {&#10;                    continue;&#10;                }&#10;&#10;                try {&#10;                    // si déjà en cache, pas besoin de rappeler l'API&#10;                    if (!isset($this-&gt;cache[$compSearch])) {&#10;                        // appel récursif : créera/enregistrera l'Items composant et téléchargera son image&#10;                        $this-&gt;getByName($compName);&#10;                    }&#10;                } catch (\Throwable $e) {&#10;                    // ne pas bloquer la création de l'item principal si un composant échoue&#10;                }&#10;            }&#10;        }&#10;&#10;        // 4. Sauvegarde en BDD&#10;        $this-&gt;em-&gt;persist($item);&#10;        $this-&gt;em-&gt;flush();&#10;&#10;        // 5. Ajout dans l’array cache&#10;        $this-&gt;cache[$searchName] = $item;&#10;&#10;        return $item;&#10;    }&#10;&#10;    private function normalizeName(string $name): string&#10;    {&#10;        return mb_strtolower(trim($name));&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="&lt;?php&#10;&#10;namespace App\Service;&#10;&#10;use App\Entity\Items;&#10;use App\Repository\ItemsRepository;&#10;use Doctrine\ORM\EntityManagerInterface;&#10;use Symfony\Component\HttpFoundation\File\UploadedFile;&#10;&#10;class ItemsProvider&#10;{&#10;    /** @var Items[] */&#10;    private array $cache = [];&#10;&#10;    public function __construct(&#10;        private ItemsRepository $repository,&#10;        private EntityManagerInterface $em,&#10;        private WarframeApiClient $apiClient,&#10;    ) {}&#10;&#10;    public function getByName(string $name): ?Items&#10;    {&#10;        $searchName = $this-&gt;normalizeName($name);&#10;&#10;        // 1. Check dans l’array du service (cache de la requête)&#10;        if (isset($this-&gt;cache[$searchName])) {&#10;            return $this-&gt;cache[$searchName];&#10;        }&#10;&#10;        // 2. Check en BDD en comparant nameEn/nameFr/uniqueName ou le JSON search_names&#10;        $item = $this-&gt;repository-&gt;findOneBySearchNameMatching($searchName);&#10;        if ($item) {&#10;            // si l'enregistrement existe mais ne contient pas le searchName dans le JSON, on l'ajoute&#10;            if (!in_array($searchName, $item-&gt;getSearchNames(), true)) {&#10;                $item-&gt;addSearchName($searchName);&#10;                $this-&gt;em-&gt;persist($item);&#10;                $this-&gt;em-&gt;flush();&#10;            }&#10;&#10;            $this-&gt;cache[$searchName] = $item;&#10;            return $item;&#10;        }&#10;&#10;        // 3. Sinon, fetch via l’API (EN + FR)&#10;        $dataEn = $this-&gt;apiClient-&gt;searchItem($name, 'en');&#10;        $dataFr = $this-&gt;apiClient-&gt;searchItem($name, 'fr');&#10;&#10;        if (empty($dataEn)) {&#10;            // rien trouvé du tout → tu peux retourner null&#10;            // ou lever une exception selon ton choix&#10;            return null;&#10;        }&#10;&#10;        // on prend le premier résultat EN comme base&#10;        $en = $dataEn[0];&#10;        $fr = !empty($dataFr) ? $dataFr[0] : null;&#10;&#10;        $item = new Items();&#10;        $item-&gt;setSearchName($searchName);&#10;        $item-&gt;setUniqueName($en['uniqueName'] ?? null);&#10;        $item-&gt;setNameEn($en['name'] ?? null);&#10;        $item-&gt;setDescriptionEn($en['description'] ?? null);&#10;        $item-&gt;setNameFr($fr['name'] ?? null);&#10;        $item-&gt;setDescriptionFr($fr['description'] ?? null);&#10;&#10;        $imageName = $en['imageName'] ?? null;&#10;&#10;        if ($imageName) {&#10;            $imageUrl = 'https://cdn.warframestat.us/img/' . $imageName;&#10;            $item-&gt;setImageUrl($imageUrl);&#10;&#10;            try {&#10;                $contents = @file_get_contents($imageUrl);&#10;                if ($contents !== false) {&#10;                    $ext = pathinfo($imageName, PATHINFO_EXTENSION) ?: 'jpg';&#10;                    $tmpPath = sys_get_temp_dir() . '/' . uniqid('wf_', true) . '.' . $ext;&#10;                    file_put_contents($tmpPath, $contents);&#10;&#10;                    // Déduire un mime simple depuis l'extension pour éviter l'appel à ext-fileinfo&#10;                    $extLower = strtolower($ext);&#10;                    $mime = match ($extLower) {&#10;                        'png' =&gt; 'image/png',&#10;                        'jpg', 'jpeg' =&gt; 'image/jpeg',&#10;                        'gif' =&gt; 'image/gif',&#10;                        'webp' =&gt; 'image/webp',&#10;                        default =&gt; null,&#10;                    };&#10;&#10;                    // Création d'un UploadedFile en mode test pour contourner les vérifs PHP upload&#10;                    $uploaded = new UploadedFile(&#10;                        $tmpPath,&#10;                        basename($imageName),&#10;                        $mime,&#10;                        null,&#10;                        true&#10;                    );&#10;&#10;                    $item-&gt;setImageFile($uploaded);&#10;                }&#10;            } catch (\Throwable $e) {&#10;&#10;            }&#10;        }&#10;&#10;        $item-&gt;setCategory($en['category'] ?? null);&#10;        $item-&gt;setProductCategory($en['productCategory'] ?? null);&#10;&#10;        // Si l'API renvoie des components, tenter de récupérer/créer chacun d'eux&#10;        if (!empty($en['components']) &amp;&amp; is_array($en['components'])) {&#10;            foreach ($en['components'] as $component) {&#10;                $compName = $component['name'] ?? ($component['uniqueName'] ?? null);&#10;                if (!$compName) {&#10;                    continue;&#10;                }&#10;&#10;                $compSearch = $this-&gt;normalizeName($compName);&#10;&#10;                // éviter les références circulaires vers soi-même&#10;                if ($compSearch === $searchName) {&#10;                    continue;&#10;                }&#10;&#10;                try {&#10;                    // si déjà en cache, pas besoin de rappeler l'API&#10;                    if (!isset($this-&gt;cache[$compSearch])) {&#10;                        // appel récursif : créera/enregistrera l'Items composant et téléchargera son image&#10;                        $this-&gt;getByName($compName);&#10;                    }&#10;                } catch (\Throwable $e) {&#10;                    // ne pas bloquer la création de l'item principal si un composant échoue&#10;                }&#10;            }&#10;        }&#10;&#10;        // 4. Sauvegarde en BDD&#10;        $this-&gt;em-&gt;persist($item);&#10;        $this-&gt;em-&gt;flush();&#10;&#10;        // 5. Ajout dans l’array cache&#10;        $this-&gt;cache[$searchName] = $item;&#10;&#10;        return $item;&#10;    }&#10;&#10;    private function normalizeName(string $name): string&#10;    {&#10;        return mb_strtolower(trim($name));&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>