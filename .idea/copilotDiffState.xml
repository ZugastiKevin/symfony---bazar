<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/src/Controller/SearchController.php">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/Controller/SearchController.php" />
              <option name="originalContent" value="&lt;?php&#10;// language: php&#10;namespace App\Controller;&#10;&#10;use App\Service\WarframeApiClient;&#10;use App\Service\WarframeItemFilter;&#10;use App\Dto\WarframeItemDto;&#10;use Symfony\Bundle\FrameworkBundle\Controller\AbstractController;&#10;use Symfony\Component\HttpFoundation\Request;&#10;use Symfony\Component\HttpFoundation\Response;&#10;use App\Repository\ItemsRepository;&#10;use Psr\Log\LoggerInterface;&#10;use Symfony\Component\Routing\Annotation\Route;&#10;&#10;class SearchController extends AbstractController&#10;{&#10;    private WarframeApiClient $warframeApi;&#10;    private ItemsRepository $itemsRepository;&#10;    private LoggerInterface $logger;&#10;    private WarframeItemFilter $itemFilter;&#10;&#10;    public function __construct(WarframeApiClient $warframeApi, ItemsRepository $itemsRepository, LoggerInterface $logger, WarframeItemFilter $itemFilter)&#10;    {&#10;        $this-&gt;warframeApi = $warframeApi;&#10;        $this-&gt;itemsRepository = $itemsRepository;&#10;        $this-&gt;logger = $logger;&#10;        $this-&gt;itemFilter = $itemFilter;&#10;    }&#10;&#10;    #[Route('/search', name: 'search', methods: ['GET'])]&#10;    public function search(Request $request): Response&#10;    {&#10;        $searchQuery = (string) $request-&gt;query-&gt;get('query', '');&#10;        $searchSource = (string) $request-&gt;query-&gt;get('source', 'db');&#10;        $language = (string) $request-&gt;query-&gt;get('lang', 'en');&#10;        $filterCategory = $request-&gt;query-&gt;get('category');&#10;        $filterOnlyTradable = $request-&gt;query-&gt;get('tradable');&#10;&#10;        if (trim($searchQuery) === '') {&#10;            return $this-&gt;render('home/_search_results.html.twig', ['results' =&gt; []]);&#10;        }&#10;&#10;        $finalResults = [];&#10;&#10;        if ($searchSource === 'api') {&#10;            try {&#10;                $rawItems = $this-&gt;warframeApi-&gt;searchItem($searchQuery, $language);&#10;&#10;                if (!is_array($rawItems) || empty($rawItems)) {&#10;                    $this-&gt;logger-&gt;info('Warframe API returned empty result', ['searchQuery' =&gt; $searchQuery, 'language' =&gt; $language]);&#10;                    $rawItems = [];&#10;                }&#10;&#10;                // Transformer en DTO&#10;                $dtoItems = [];&#10;                foreach ($rawItems as $rawItem) {&#10;                    $dtoItems[] = WarframeItemDto::fromArray((array) $rawItem);&#10;                }&#10;&#10;                // Interpréter le param tradable (peut venir en string '1' ou 'true')&#10;                $onlyTradable = null;&#10;                if ($filterOnlyTradable !== null) {&#10;                    $onlyTradable = in_array(strtolower((string) $filterOnlyTradable), ['1', 'true', 'yes'], true);&#10;                }&#10;&#10;                // Filtrer par catégorie et tradable&#10;                $filteredDtoItems = $this-&gt;itemFilter-&gt;filterByCategoryAndTradable($dtoItems, $filterCategory ?? null, $onlyTradable);&#10;&#10;                // Convertir en tableau simple pour le template&#10;                foreach ($filteredDtoItems as $dtoItem) {&#10;                    $finalResults[] = $dtoItem-&gt;toArray();&#10;                }&#10;&#10;            } catch (\Throwable $caughtError) {&#10;                $this-&gt;logger-&gt;error('Erreur lors de l\'appel à l\'API Warframe', [&#10;                    'searchQuery' =&gt; $searchQuery,&#10;                    'language' =&gt; $language,&#10;                    'message' =&gt; $caughtError-&gt;getMessage(),&#10;                ]);&#10;            }&#10;        } else {&#10;            $dbResults = $this-&gt;itemsRepository-&gt;searchByTerm($searchQuery);&#10;            // Si la repository retourne déjà un tableau d'items, on peut les utiliser&#10;            $finalResults = $dbResults;&#10;        }&#10;&#10;        return $this-&gt;render('home/_search_results.html.twig', [&#10;            'results' =&gt; $finalResults,&#10;        ]);&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="&lt;?php&#10;// language: php&#10;namespace App\Controller;&#10;&#10;use App\Service\WarframeApiClient;&#10;use App\Service\WarframeItemFilter;&#10;use App\Dto\WarframeItemDto;&#10;use Symfony\Bundle\FrameworkBundle\Controller\AbstractController;&#10;use Symfony\Component\HttpFoundation\Request;&#10;use Symfony\Component\HttpFoundation\Response;&#10;use App\Repository\ItemsRepository;&#10;use Psr\Log\LoggerInterface;&#10;use Symfony\Component\Routing\Annotation\Route;&#10;&#10;class SearchController extends AbstractController&#10;{&#10;    private WarframeApiClient $warframeApi;&#10;    private ItemsRepository $itemsRepository;&#10;    private LoggerInterface $logger;&#10;    private WarframeItemFilter $itemFilter;&#10;&#10;    public function __construct(WarframeApiClient $warframeApi, ItemsRepository $itemsRepository, LoggerInterface $logger, WarframeItemFilter $itemFilter)&#10;    {&#10;        $this-&gt;warframeApi = $warframeApi;&#10;        $this-&gt;itemsRepository = $itemsRepository;&#10;        $this-&gt;logger = $logger;&#10;        $this-&gt;itemFilter = $itemFilter;&#10;    }&#10;&#10;    #[Route('/search', name: 'search', methods: ['GET'])]&#10;    public function search(Request $request): Response&#10;    {&#10;        $searchQuery = (string) $request-&gt;query-&gt;get('query', '');&#10;        $searchSource = (string) $request-&gt;query-&gt;get('source', 'db');&#10;        $language = (string) $request-&gt;query-&gt;get('lang', 'en');&#10;        $filterCategory = $request-&gt;query-&gt;get('category');&#10;        $filterOnlyTradable = $request-&gt;query-&gt;get('tradable');&#10;&#10;        if (trim($searchQuery) === '') {&#10;            return $this-&gt;render('home/_search_results.html.twig', ['results' =&gt; []]);&#10;        }&#10;&#10;        $finalResults = [];&#10;&#10;        if ($searchSource === 'api') {&#10;            try {&#10;                $rawItems = $this-&gt;warframeApi-&gt;searchItem($searchQuery, $language);&#10;&#10;                if (!is_array($rawItems) || empty($rawItems)) {&#10;                    $this-&gt;logger-&gt;info('Warframe API returned empty result', ['searchQuery' =&gt; $searchQuery, 'language' =&gt; $language]);&#10;                    $rawItems = [];&#10;                }&#10;&#10;                // Transformer en DTO&#10;                $dtoItems = [];&#10;                foreach ($rawItems as $rawItem) {&#10;                    $dtoItems[] = WarframeItemDto::fromArray((array) $rawItem);&#10;                }&#10;&#10;                // Interpréter le param tradable (peut venir en string '1' ou 'true')&#10;                $onlyTradable = null;&#10;                if ($filterOnlyTradable !== null) {&#10;                    $onlyTradable = in_array(strtolower((string) $filterOnlyTradable), ['1', 'true', 'yes'], true);&#10;                }&#10;&#10;                // Filtrer par catégorie et tradable&#10;                $filteredDtoItems = $this-&gt;itemFilter-&gt;filterByCategoryAndTradable($dtoItems, $filterCategory ?? null, $onlyTradable);&#10;&#10;                // Convertir en tableau simple pour le template&#10;                foreach ($filteredDtoItems as $dtoItem) {&#10;                    $finalResults[] = $dtoItem-&gt;toArray();&#10;                }&#10;&#10;            } catch (\Throwable $caughtError) {&#10;                $this-&gt;logger-&gt;error('Erreur lors de l\'appel à l\'API Warframe', [&#10;                    'searchQuery' =&gt; $searchQuery,&#10;                    'language' =&gt; $language,&#10;                    'message' =&gt; $caughtError-&gt;getMessage(),&#10;                ]);&#10;            }&#10;        } else {&#10;            $dbResults = $this-&gt;itemsRepository-&gt;searchByTerm($searchQuery);&#10;            // Si la repository retourne déjà un tableau d'items, on peut les utiliser&#10;            $finalResults = $dbResults;&#10;        }&#10;&#10;        return $this-&gt;render('home/_search_results.html.twig', [&#10;            'results' =&gt; $finalResults,&#10;        ]);&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/Service/WarframeItemFilter.php">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/Service/WarframeItemFilter.php" />
              <option name="originalContent" value="&lt;?php&#10;&#10;namespace App\Service;&#10;&#10;use App\Dto\WarframeItemDto;&#10;&#10;class WarframeItemFilter&#10;{&#10;    public function filterByCategoryAndTradable(array $items, ?string $category = null, ?bool $onlyTradable = null): array&#10;    {&#10;        $out = [];&#10;&#10;        foreach ($items as $item) {&#10;            if (!($item instanceof WarframeItemDto)) {&#10;                continue;&#10;            }&#10;&#10;            if ($category !== null &amp;&amp; $item-&gt;getCategory() !== null) {&#10;                if (strtolower($item-&gt;getCategory()) !== strtolower($category)) {&#10;                    continue;&#10;                }&#10;            }&#10;&#10;            if ($onlyTradable === true) {&#10;                if ($item-&gt;isTradable() !== true) {&#10;                    continue;&#10;                }&#10;            }&#10;&#10;            $out[] = $item;&#10;        }&#10;&#10;        return $out;&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="&lt;?php&#10;&#10;namespace App\Service;&#10;&#10;use App\Dto\WarframeItemDto;&#10;&#10;class WarframeItemFilter&#10;{&#10;    public function filterByCategoryAndTradable(array $items, ?string $category = null, ?bool $onlyTradable = null): array&#10;    {&#10;        $out = [];&#10;&#10;        foreach ($items as $item) {&#10;            if (!($item instanceof WarframeItemDto)) {&#10;                continue;&#10;            }&#10;&#10;            if ($category !== null &amp;&amp; $item-&gt;getCategory() !== null) {&#10;                if (strtolower($item-&gt;getCategory()) !== strtolower($category)) {&#10;                    continue;&#10;                }&#10;            }&#10;&#10;            if ($onlyTradable === true) {&#10;                if ($item-&gt;isTradable() !== true) {&#10;                    continue;&#10;                }&#10;            }&#10;&#10;            $out[] = $item;&#10;        }&#10;&#10;        return $out;&#10;    }&#10;}&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>